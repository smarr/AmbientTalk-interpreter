=== TODO ===

checklist:
- nadenken over modulair uitbreiden van de code met standard libraries (bvb. at.exceptions.interpreter)
=> zoveel mogelijk in AT zelf schrijven => symbiose mogelijke uitweg voor de nodige native code snippets?

- NATNil moet createChild oproepen.

- zorgen dat alle AT interfaces alleen nog base_ / meta_ methoden hebben? Vooral ATConversions, AGxxx

- mirages + unit tests
- write AmbientTalk code: at.collections, at.unit, at.init, at.mirrors
- use AspectJ introduction to separate passive obj model from active obj model
- concurrency: add actors(vats) + message queues + threading/concurrency control + async msg passing
- distribution: add comm protocol, discovery protocol, remote actors (what about using a lightweight lib?)

- Symbiosis:
=> introduce a 'jlobby' namespace similar to lobby, but initialized with CLASSPATH of JVM instead of OBJECTPATH -> can be queried for classes! e,g, jlobby.java.lang.String, jlobby.edu.vub.at.Evaluator, ...
JavaPackage = namespace, JavaClass = object that understands 'new' and static methods, JavaObject = object whose methods become methods, whose getter/setter methods become fields
Solve overloading by being able to annotate a method invocation => future work
=> Automatic conversions: use coercers for going from an ATObject to a Java interface type
For symbiosis, reuse coercers to make NATObjects implement arbitrary Java interfaces, such as an ActionListener
=> Exceptions map to generic AT exceptions
=> Threads -> currently 'you're on your own'? or consider wrapping each ATObject in a coercer that also acts as a far ref => converts invocations into enqueues, but this requires futures to block the waiting Java Thread

- Reflection
* Review and fix mirrors and mirages (add/remove "base" and "meta" prefix consistently to all methods in AT interfaces)
* isXXX and asXXX must become meta_isXXX and meta_asXXX

- Core language evaluator
* remove as much .asNative...() casts from the code as possible. Each such cast precludes use of custom AT objects.

* find a suitable semantics for object 'instantiation'.
problem: 'init' is not a 'normal' method, if it would be, and you would invoke obj.clone.init, you might
invoke the 'init' method of a 'shares-a' parent object that did not get cloned!
two solutions:
1) remove 'shares-a' parents from the language ; you can still do parent sharing by invoking o.extend { ... } twice on the same object o
the idea is that all delegation links will then be is-a, so you don't have the 'init' problem anymore: you can search up to the root for 'init'.
2) make 'object initialization' a dedicated meta-level operation (i.e. meta_init). meta_init(args) is almost the same as meta_invoke("init", args),
except that the lookup for init does not traverse shares-a links...
The one 'problem' remaining is that init can always be invoked on a 'live' (already initialized) object... unless meta_invoke is modified as
to give an error when invoking 'init' (i.e. 'init' should only be invoked via meta_init and never via meta_invoke("init"), then you can
make sure it's called only once.
Perhaps a cleaner meta-level interface is having meta_clone and meta_new => clone makes a clone without initializing it, new also does initialization.
The reason being that explicitly providing meta_init allows base-level code to re-initialize a live object at the meta-level.

* meta_defineField versus meta_addField => perhaps defineField is not accessible from the
meta-level and should be renamed to defineField. Similarly, meta_assignField should come in two
variants: meta_assignField(ATField f, ATObject val) and assignField(ATSymbol sel, ATObject val).
The problem then becomes: ATObject interface only supports the meta_... variants, meaning that
the evaluation code will require an .isNativeObject() -> .asNativeObject().defineField(...) check.