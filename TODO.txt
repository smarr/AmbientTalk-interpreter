=== TODO ===

checklist:
- nadenken over modulair uitbreiden van de code met standard libraries (bvb. at.exceptions.interpreter)
=> zoveel mogelijk in AT zelf schrijven => symbiose mogelijke uitweg voor de nodige native code snippets?

- zorgen dat alle AT interfaces alleen nog base_ / meta_ methoden hebben die InterpreterException throwen
en die alleen AT args of convertible args returnen / nemen
violators:
NATText meta_print() throws InterpreterException;
alle isXXX() methods => returnen boolean
ATObject base_object_mirroredBy_(ATClosure code, NATIntercessiveMirror mirror) throws InterpreterException;
en varianten: nemen expliciet een NATIntercessiveMirror ipv een ATMirror
		
- mirages + unit tests

- write AmbientTalk code: at.collections, at.unit, at.init, at.mirrors

- concurrency: add actors(vats) + message queues + threading/concurrency control + async msg passing
- distribution: add comm protocol, discovery protocol, remote actors (what about using a lightweight lib?)

- Symbiosis:
=> Solve overloading by being able to annotate a method invocation => future work
=> Threads -> currently 'you're on your own'? or consider wrapping each ATObject in a coercer that also acts as a far ref => converts invocations into enqueues, but this requires futures to block the waiting Java Thread
=> Implementation can be sped up a bit using caching, consider a cache for Symbiosis.getMethods
requires to change implementation of Symbiosis.invokeSymbioticMethod not to filter out methods by assigning null
=> representing array types in AT, i.e. how to access a wrapper for Type[] classes?
Normally, arrays are represented as tables and vice versa, but for base_cast, requires explicit type wrapper for arrays
=> casting for constructors
=> methods with _ in Java

- Reflection
* isXXX and asXXX must become meta_isXXX and meta_asXXX

- Core language evaluator
* remove as much .asNative...() casts from the code as possible. Each such cast precludes use of custom AT objects.

* find a suitable semantics for object 'instantiation'.
problem: 'init' is not a 'normal' method, if it would be, and you would invoke obj.clone.init, you might
invoke the 'init' method of a 'shares-a' parent object that did not get cloned!
two solutions:
1) remove 'shares-a' parents from the language ; you can still do parent sharing by invoking o.extend { ... } twice on the same object o
the idea is that all delegation links will then be is-a, so you don't have the 'init' problem anymore: you can search up to the root for 'init'.
2) make 'object initialization' a dedicated meta-level operation (i.e. meta_init). meta_init(args) is almost the same as meta_invoke("init", args),
except that the lookup for init does not traverse shares-a links...
The one 'problem' remaining is that init can always be invoked on a 'live' (already initialized) object... unless meta_invoke is modified as
to give an error when invoking 'init' (i.e. 'init' should only be invoked via meta_init and never via meta_invoke("init"), then you can
make sure it's called only once.
Perhaps a cleaner meta-level interface is having meta_clone and meta_new => clone makes a clone without initializing it, new also does initialization.
The reason being that explicitly providing meta_init allows base-level code to re-initialize a live object at the meta-level.
update: why not introduce syntax: new <expression>(arguments) , which is equivalent to: (reflect: <expression>).new(arguments)

* meta_defineField versus meta_addField => perhaps defineField is not accessible from the
meta-level and should be renamed to defineField. Similarly, meta_assignField should come in two
variants: meta_assignField(ATField f, ATObject val) and assignField(ATSymbol sel, ATObject val).
The problem then becomes: ATObject interface only supports the meta_... variants, meaning that
the evaluation code will require an .isNativeObject() -> .asNativeObject().defineField(...) check.
=> add a meta_defineFunction operation to ignore the if-test in AGDef...

* zoveel mogelijk native methods vervangen door code gedumpt in de init.at file
bvb. alle controlestructuren, isXXX: methoden, ...