=== TODO ===

* ensure meta_print is overridden in each NAT class.

- Natives
* meta_new in NATNil -> turn into constructor call at Java level

- Reflection
* Review and fix mirrors and mirages (add/remove "base" and "meta" prefix)

- Core language evaluator
* remove as much .asNative...() casts from the code as possible. Each such cast precludes use of custom AT objects.

* find a suitable semantics for object 'instantiation'.
problem: 'init' is not a 'normal' method, if it would be, and you would invoke obj.clone.init, you might
invoke the 'init' method of a 'shares-a' parent object that did not get cloned!
two solutions:
1) remove 'shares-a' parents from the language ; you can still do parent sharing by invoking o.extend { ... } twice on the same object o
the idea is that all delegation links will then be is-a, so you don't have the 'init' problem anymore: you can search up to the root for 'init'.
2) make 'object initialization' a dedicated meta-level operation (i.e. meta_init). meta_init(args) is almost the same as meta_invoke("init", args),
except that the lookup for init does not traverse shares-a links...
The one 'problem' remaining is that init can always be invoked on a 'live' (already initialized) object... unless meta_invoke is modified as
to give an error when invoking 'init' (i.e. 'init' should only be invoked via meta_init and never via meta_invoke("init"), then you can
make sure it's called only once.
Perhaps a cleaner meta-level interface is having meta_clone and meta_new => clone makes a clone without initializing it, new also does initialization.
The reason being that explicitly providing meta_init allows base-level code to re-initialize a live object at the meta-level.

* removing meta_invoke from the ATObject interface?
a meta_invoke could be simulated by doing a meta_select + meta_apply.
similar to meta_call = meta_lookup + meta_apply
=> would simplify ATObject
=> repercussions on code? e.g. on reflective invocations in Java: table.at() would then have to be transformed to meta_select("at") (which returns an ATClosure wrapper around a Java method) + meta_apply which triggers the Java method.
would be less efficient

* meta_defineField versus meta_addField => perhaps defineField is not accessible from the
meta-level and should be renamed to defineField. Similarly, meta_assignField should come in two
variants: meta_assignField(ATField f, ATObject val) and assignField(ATSymbol sel, ATObject val).
The problem then becomes: ATObject interface only supports the meta_... variants, meaning that
the evaluation code will require an .isNativeObject() -> .asNativeObject().defineField(...) check.