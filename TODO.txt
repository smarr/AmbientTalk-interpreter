=== TODO ===

checklist:
- nadenken over modulair uitbreiden van de code met standard libraries (bvb. at.exceptions.interpreter)
=> zoveel mogelijk in AT zelf schrijven => symbiose mogelijke uitweg voor de nodige native code snippets?

- zorgen dat alle AT interfaces alleen nog base_ / meta_ methoden hebben die InterpreterException throwen
en die alleen AT args of convertible args returnen / nemen
violators:
NATText meta_print() throws InterpreterException;
alle isXXX() methods => returnen boolean
ATObject base_object_mirroredBy_(ATClosure code, NATIntercessiveMirror mirror) throws InterpreterException;
en varianten: nemen expliciet een NATIntercessiveMirror ipv een ATMirror
		
- mirages + unit tests

- write AmbientTalk code: at.collections, at.unit, at.init, at.mirrors

- concurrency: add actors(vats) + message queues + threading/concurrency control + async msg passing
- distribution: add comm protocol, discovery protocol, remote actors (what about using a lightweight lib?)

- Symbiosis:
=> Solve overloading by being able to annotate a method invocation => future work
=> Threads -> currently 'you're on your own'? or consider wrapping each ATObject in a coercer that also acts as a far ref
    => converts invocations into enqueues, but this requires futures to block the waiting Java Thread
om callbacks Java -> AT en Java Threads deftig te ondersteunen zou elke externe java thread
(i.e. elke java thread behalve de thread die de actor zelf voorstelt) AT objecten alleen async mogen invokeren
dit kan makkelijk in coercer.invoke:
if (currentthread == actorthread)
   do invoke synchronously
else
   schedule msg + future in actor queue
   future.wait()
=> actor thread moet msg.resultComputed(res) oproepen hetgeen dan voor dit soort msges de thread kan doen unblocken

=> Implementation can be sped up a bit using caching. Currently, only methods are cached, could also
cache Constructors if we introduce a JavaConstructor class? This could also be used to solve problem of
casting for constructors. E.g. if aClass.new returns a JavaConstructor which is a special kind of JavaClosure,
then we can do aClass.new.cast(Type1, Type2)(a, b)

=> representing array types in AT, i.e. how to access a wrapper for Type[] classes?
Normally, arrays are represented as tables and vice versa, but for base_cast, requires explicit type wrapper for arrays
=> casting for constructors
=> methods with _ in Java: suggestion is to allow _ in AT identifiers, only disadvantage is that Java identifiers with _
will be displayed using : in AT. However, an AT selector will not undergo such conversions when remaining within AT,
so that should be ok. Can be made even cleaner if the _ -> : conversion is only performed for downSelector, and for symbiosis
introduce another method named 'javaToATSelector'

- Reflection
* isXXX and asXXX must become meta_isXXX and meta_asXXX

- Next to the == operator, which defines equality through identity, we should introduce
an operator = which defines structural equality
e.g. [2,3] is not == to [2,3] but [2,3] = [2,3]
likewise: object: { def a := 1 } is not == to another such object (only == to itself)
but = could by default do a field-wise comparison
deep equality.

Apart from an = and == operator, we could also introduce a <: operator
which defines a kind of subtype relationship in terms of the public fields or methods
of an object

e.g.
boolean NATNil.base__opltx__(ATObject other) {
  foreach field | method selector of this {
    if (other.meta_respondsTo(selector) {
       continue;
    } else {
       return false;
    }
  }
  return dynamicParent_.base__opeql_(other.meta_getDynamicParent());
}
(NATObject/NATCallframe could have specialized implementation)
NATTable also needs specialized impl.

the default semantics of '=' is '=='? (e.g. numbers, etc.)
Note that structural equivalence of objects is defined in terms of their public fields/methods
+ those of their dynamic parents. Lexical parents are not taken into consideration, as they are
considered 'private' to the object.

- Core language evaluator
* remove as much .asNative...() casts from the code as possible. Each such cast precludes use of custom AT objects.

* find a suitable semantics for object 'instantiation'.
problem: 'init' is not a 'normal' method, if it would be, and you would invoke obj.clone.init, you might
invoke the 'init' method of a 'shares-a' parent object that did not get cloned!
two solutions:
1) remove 'shares-a' parents from the language ; you can still do parent sharing by invoking o.extend { ... } twice on the same object o
the idea is that all delegation links will then be is-a, so you don't have the 'init' problem anymore: you can search up to the root for 'init'.
2) make 'object initialization' a dedicated meta-level operation (i.e. meta_init). meta_init(args) is almost the same as meta_invoke("init", args),
except that the lookup for init does not traverse shares-a links...
The one 'problem' remaining is that init can always be invoked on a 'live' (already initialized) object... unless meta_invoke is modified as
to give an error when invoking 'init' (i.e. 'init' should only be invoked via meta_init and never via meta_invoke("init"), then you can
make sure it's called only once.
Perhaps a cleaner meta-level interface is having meta_clone and meta_new => clone makes a clone without initializing it, new also does initialization.
The reason being that explicitly providing meta_init allows base-level code to re-initialize a live object at the meta-level.
update: why not introduce syntax: new <expression>(arguments) , which is equivalent to: (reflect: <expression>).new(arguments)

* zoveel mogelijk native methods vervangen door code gedumpt in de init.at file
bvb. alle controlestructuren, isXXX: methoden, ...